/*
 * This file is part of the [Apollo] project.
 * Copyright [2023] [Rui Zhang] and other contributors.
 * See the LICENSE file in the project root directory for the full license information.
 * 
 * The sharing rights for this project belong to all those who have contributed to the project.
 * 
 * Thanks to the following contributors for their dedication and support of this project:
 *   - Rui Zhang 
*/


# include <iostream>
# include <windows.h>
# include <io.h>
# include <map>
# include <string>
# include <stdlib.h>

using namespace std;


extern FILE * yyin;
extern int yylex();


# define __0xffffffff "F\\F\\F\\F\\F\\F\\F\\F\\"

extern string f_read    (string);
extern void f_write (string, string);

extern int __pc_index;

extern map<int, string> memory_map;
extern map<int, bool>   cdtblock;

string memory_root;
string fn;
string cs_loc;

inline string ffn (const string &);
inline string convert (const string &, bool);

string _py_before = "\n\
#    Copyright [2023] [Rui Zhang] \n\
# \n\
#   Licensed under the Apache License, Version 2.0 (the \"License\"); \n\
#   you may not use this file except in compliance with the License. \n\
#   You may obtain a copy of the License at \n\
# \n\
#       http://www.apache.org/licenses/LICENSE-2.0 \n\
# \n\
#   Unless required by applicable law or agreed to in writing, software \n\
#   distributed under the License is distributed on an \"AS IS\" BASIS, \n\
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n\
#   See the License for the specific language governing permissions and \n\
#   limitations under the License. \n\
# \n\
#   Code last change date: 2023-1-20 \n\
# \n\
#   This python code file is automatically generated by Apollo compiler. \n\
#   The purpose of this file is to separate the process control code snippets \n\
# from the `Apollo Code Source File` and to give accurate and valid markings in the source file. \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
def replace (file, old, new): \n\
    code = rfile(file) \n\
    code = code.replace(old, new) \n\
    wfile(file, code) \n\
\n\
def rfile (file): \n\
    with open(file, encoding = 'UTF-8') as f: \n\
        read_all = f.read() \n\
        f.close() \n\
    return read_all \n\
\n\
def wfile (file, data): \n\
    with open(file, 'w', encoding = 'UTF-8') as f: \n\
        f.write(data) \n\
        f.close() \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
import os \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
p_basic = os.path.dirname(__file__) \n\
p_mode  = p_basic + '\\.mode' \n\
p_file  = p_basic + '\\.file' \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
smode = rfile(p_mode) \n\
sfile = rfile(p_file) \n\
\n\
";

string _py_after = "\n\
for i in range(len(M)): \n\
    old = rfile(M[i]) \n\
    new = ' /* @compiler %call (pc) ' + O[i] + ' ' + C[i] + ' */ ' \n\
\n\
    if smode == 's': \n\
        replace(sfile, old, new) \n\
    elif smode == 'r': \n\
        replace(sfile, new, old) \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
";


string _py_M_list = "M = [ ";
string _py_O_list = "O = [ ";
string _py_C_list = "C = [ ";

string _list_close = "] \n";

# define PUSH(addr)     _py_M_list += ("'" + convert(addr, false) + "', " );    \
                        _py_O_list += ( "'" + addr + "', " )
# define PUSH_OK(addr)  _py_M_list += ( "'" + convert(addr, false) + "' " );     \
                        _py_O_list += ( "'" + addr + "' " )

# define PUSH_CDT(value)    _py_C_list += "'" + value + "', "
# define PUSH_CDT_OK(value) _py_C_list += "'" + value + "' "


int main (int args, char * argv[])
{
    string s    = string((const char *)argv[1]);
    memory_root = string((const char *)getenv("APOLLO_MEMORY"));


    if (s.size() == 10 && s[1] == 'x') 
    {
        fn = s;
        if(yyin = fopen(convert(s, false).c_str(), "r")) 
        {
            cs_loc = memory_root + __0xffffffff + fn + "\\code-snippets";
                if (_access(cs_loc.c_str(), 0) == -1) system(string("mkdir " + cs_loc).c_str());
            cs_loc += '\\';
        } else 
        {
            cerr << "not found the file in pc" << endl;
            return -1;
        }
    } 
    else
    if (yyin = fopen(argv[1], "r")) 
    {
        fn = (const char *)argv[1];
        cs_loc = memory_root + __0xffffffff + fn + "\\code-snippets";
            if (_access(cs_loc.c_str(), 0) == -1) system(string("mkdir " + cs_loc).c_str());
        cs_loc += '\\';
    } 
    else 
    {
        cerr << "not found the file in .." << endl;
        return -1;
    }

    // analysis
    yylex();


    for (int i = 0; i <= __pc_index; ++i) 
    {   
        string cdt_v = cdtblock[i] ? "true" : "false";   
        if (i != __pc_index) 
        {
            PUSH(memory_map[i]);
            PUSH_CDT(cdt_v);
        } 
        else 
        {
            PUSH_OK(memory_map[i]);
            PUSH_CDT_OK(cdt_v);
        }
    }

    _py_M_list += _list_close;
    _py_O_list += _list_close;
    _py_C_list += _list_close;

    // cout << '\n' << _py_M_list << endl;
    // cout << _py_O_list << endl;
    // cout << _py_C_list << endl;

    string py = _py_before + _py_M_list + _py_O_list + _py_C_list + _py_after;

    // Python file of separation
    f_write(cs_loc + "pc.py", py);

    if (fn.size() == 10 && fn[1] == 'x') 
    {
        string t1 = convert(fn, false);
        f_write(cs_loc + ".file", t1);
    } 
    else 
    {
        f_write(cs_loc + ".file", fn);
    }

    system(string("python " + cs_loc + "pc.py").c_str());
    return 0;
}


inline string ffn (const string &_path) 
{
	string s = _path, r;

	int mark = 0;
	
	for (auto &c : s) {
		if (mark == 1) { 
			r = (c == '/' || c == '\\') ? r + '-' : r + c;
			continue;
		}

		if (c == '\0') 
			break;
		else if (c == '/' || c == '\\') 
			mark = 1;
		else {
			mark = 0;
		}
	}

	return r;
}


inline string convert (const string &__addr, bool __create) 
{
    string t, t1 = __addr,  m2;
    int i = 0; for (auto const &c : t1) {
        if (i++ < 2 && t1[1] == 'x') 
            continue;
        m2 += c;
        m2 += '/';
    }

    string t2;

    for (auto const &c : memory_root) 
    {
        if (c == '\\') 
            t2 += '/';
        else 
            t2 += c;
    }

    t = t2 + m2;

    if (__create && _access(t.c_str(), 0) == -1) 
        system(string("mkdir " + t).c_str());

    t += ".data";
    return t;
}




