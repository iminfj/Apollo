/*
 * This file is part of the [Apollo] project.
 * Copyright [2023] [Rui Zhang] and other contributors.
 * See the LICENSE file in the project root directory for the full license information.
 * 
 * The sharing rights for this project belong to all those who have contributed to the project.
 * 
 * Thanks to the following contributors for their dedication and support of this project:
 *   - Rui Zhang 
*/


# include <iostream>
# include <vector>
# include <string>
# include <sstream>
# include <cstdio>
# include <cstring>
# include <math.h>
# include <io.h>
# include <Windows.h>
# include <stdio.h>
# include <stdlib.h>
# include <direct.h>

# ifdef _WIN32
# include <Windows.h>
# else
# include <unistd.h>
# endif

# include <apollo/Utils/HashTable.hpp>
# include <apollo/Utils/Stack.hpp>
# include <apollo/Utils/uuid.hpp>

using namespace std;


/* macro */
# define __0xffffffff	"F\\F\\F\\F\\F\\F\\F\\F\\"
# define _0xffffffff	"0xFFFFFFFF"
# define __PC			".pc"
# define __DATA			".data"

int alog_i = 0;
# define ALOG ( cout << "Log Id: " << (++alog_i) << endl )

# define _Const_Apollo_CRTVersion	"Apollo Summer. Version alpha 23.1"
# define _Const_Apollo_Prompt		"We are looking for Apollo Language community members or code contributors, you are welcome to join!"

/**
 * |--Vector-M--|
 * | 0x00000001 |
 * | 0x00000002 |
 * | 0xABCDEF12 |
 * | ...		|
 * |------------|
*/
/// @brief Memory allocation table: The memory addresses allocated to the program by the compiler(interpreter) are recorded in this table
extern vector<string> __memory_alloc_list;

extern vector<string> temp_uss_tag_list;
extern vector<string> delete_list;

/// @brief Pointer to the file to be parsed
extern FILE *yyin;
/// @brief Used to indicate the line number being parsed
extern int yylineno;
/// @brief Parser functions for the syntax parser generated by GNU Bison
/// @return An int value
extern int yyparse();



/// @brief Change the value of the string at depth @a w
/// @param sa (input) File address with \ or / as depth boundary
/// @param sb (target) The string value with depth @a w is changed to @a sb
/// @param w Depth
/// @return string - New file address
inline string cdir (const string &sa, const string &sb, int w);
/// @brief Restore all memory occupied by the program when it was running
inline void memory_recovery ();
inline string __memory_address_convert (const string &);
inline void final_mission();
inline void preparing_mission();
inline string f_read (const string &);
inline void	f_write (const string &, const string &);
inline string dec_to_hex (int64_t);
inline int64_t hex_to_dec (const string &);
// compatible
const char * combstr (const string &, const string &);
// compatible

/// @brief Absolute address of the Apollo compiler(interpreter) environment
string apo_env_loc = string((const char *)getenv("APOLLO_HOME"));
/// @brief Root address of Apollo memory area
string memory_env_loc = string((const char *)getenv("APOLLO_MEMORY"));
/// @brief The file name of the program, which can be understood as the relative path to the file being compiled
string fn;
/// @brief If true, this means that no compiler arguments are used
bool no_args = false;

int Main			= 0;
int Function		= 1;
int ProcessControl	= 2;

int cplt_t = Main;

string location;

int pci;

# include <map>

// <identifier, address>
map<string, string> reference_codes;

/**
 * K -- -- -- -- + -- -- -- -- V
 * 0xAB CD EF 12 |		   true
 * <MEMORY_ADDR> | (true|false)
 * E -- -- -- -- - -- -- -- -- E
*/
/// @brief Memory release hash table
HashTable _memory_release_table;


/// @brief Function Name
vector<string>	cache_k;
/// @brief Function Body
vector<string>	cache_v;


/// @brief If the compiler(interpreter) argument: `--func` is used, the value will be true
bool __is_func = false;
string __func_fn;




/* compatible */
	const char * combstr (const string &a, const string &b) 
		{ return _strdup(string(a + b).c_str()); }
/* compatible */

inline string cdir (const string &sa, const string &sb, int w) 
{
	int n = 0, n1 = 0;
	string r;

	for (auto const &c : sa) 
		if (c == '\\' || c == '/') ++n;

	for (auto const &c : sa) {
		r = r + c;
		if (c == '\\' || c == '/') 
			++n1;
		if (n1 == (n - w)) 
			break;
	}
	r += sb;
	return r;
}

const char * apo_file_fullname (const char * _address) {
	string s = _address, r;

	int mark = 0;
	
	for (auto &c : s) {
		if (mark == 1) { 
			r = (c == '/' || c == '\\') ? r + '_' : r + c;
			continue;
		}

		if (c == '\0') 
			break;
		else if (c == '/' || c == '\\') 
			mark = 1;
		else {
			mark = 0;
		}
	}

	return _strdup(r.c_str());
}

const char * file_suffix (const char * _address) {
    string s = _address, r;

    int mark = 0;
    
    for (auto &c : s) {
        if (mark == 1) { 
            r = r + c;
            continue;
        }

        if (c == '\0') 
            break;
        else if (c == '.') 
            mark = 1;
        else {
            mark = 0;
        }
    }

    return _strdup(r.c_str());
}

/// @brief Compare the values of two `const char*` types to see if they are the same
/// @param strA Val 1
/// @param strB Val 2
/// @return int - The same value will return 1, Not the same return 0
int equal(const char * strA, const char * strB) 
{
	return strcmp(strA, strB) == 0 ? 1 : 0;
}

string __memory_address_convert (const string &__memory_address) 
{
    string _t = memory_env_loc, __m2;

    int i = 0; for (auto const &c : __memory_address) 
	{
        if (i++ < 2 && __memory_address[1] == 'x') 
            continue;
        __m2 += c;
        __m2 += '\\';
    }

	_t += __m2;
	_t += __DATA;

    return _t;
}

/// @brief A brief summary of all compiler parameters and how to use them
static void usage() {
  cout << endl << endl << "\
Usage: apollo file           ... \n\
\n\
       apollo [OPTION] file  ... \n\
       apollo [OPTION] value ... \n\
\n\
Compile an Apollo source file.  Examples:\n\
  apollo demo.apo\n\
\n\
Options:\n\
  --version          Apollo version.\n\
  --help             A summary of usage of the Apollo compiler.\n\
\n\
  --specify-cpl	     Specify MSP compilation parameters.\n\
  --specify-cpl-c    Specify the compiler for compiling C programs.\n\
  --specify-cpl-c++                                     C++ \n\
  --specify-cpl-jdk                                     OpenJDK(Java) \n\
\n\
  --func             The prerequisite is to execute a function code and\n\
                     this compiler parameter is used to point to the memory\n\
                     location or absolute address of the function code.\n\
\n\
  --binding          Bind the memory area that the Apollo file to be run\n\
                     wants to occupy to the memory area occupied by {value}.\n\
\n\n";
}


void apo_exec(string program, string args_or_command) 
{
	system(string(apo_env_loc + program + " " + args_or_command).c_str());
}
void apo_exec(string front, string program, string args_or_command) 
{
	string s = (front + apo_env_loc + program + " " + args_or_command);
	system(s.c_str());
}

int parameters_exec (const char * argv) 
{
	if (equal(argv, "--version")) {
		cout << endl << _Const_Apollo_CRTVersion << endl << endl;
		return -1;
	} else if (equal(argv, "--help")) {
		usage();
		return -1;
	} 
	else if (equal(file_suffix(argv), "apo")) 
	{
		cplt_t = Main;

		no_args = false;

		fn = (string)argv;

// @{	Code snippet pre-processing
		// Appobj co-compilation
		apo_exec("codes.exe", argv);


		// Process Control
		apo_exec("pc.exe", argv);

		/**
		 * Start the @a function-preprocessor to get a valid 
		 @a function-signature and @a function-code .
		 */
		apo_exec("code-func.exe", argv);

// @}

		string	code_function_loc	= memory_env_loc + __0xffffffff + argv + "\\", 
				funcs_keys			= f_read(code_function_loc + "code-function.table.k"), 
				funcs_vals			= f_read(code_function_loc + "code-function.table.v"), 
				k, 
				v;
		Stack	bracket;

		// Function Signatures
		for (auto const &c : funcs_keys) 
		{
			if (c == '[') 
			{
				k.clear();
				continue;
			} else if (c == ']') 
			{
				if (!k.empty()) {
					cache_k.push_back(k);
					continue;
				}
			} else k += c;
		}

		// Function Code
		for (auto const &c : funcs_vals) 
		{
			if (c == '[') 
			{
				bracket.push(0);
				v.clear();
				continue;
			} else if (c == ']') 
			{
				bracket.pop();
				if (bracket.empty()) cache_v.push_back(v);
			} else v += c;
		}

		preparing_mission();

		// Load the source file and execute
		yyin = fopen(argv, "r");
			yyparse();
		fclose(yyin);

		// Function
		f_write((apo_env_loc + "separation\\func\\s_mode"), "r");
		// Function
		apo_exec("python ", "separation\\func\\sprt.py", "");

		// Write recovery signal - Process Control
		f_write((memory_env_loc + __0xffffffff + fn + "\\code-snippets\\.mode"), "r");
		// Startup code recovery - Process Control
		system(string("python " + memory_env_loc + __0xffffffff + fn + "\\code-snippets\\pc.py").c_str());

		f_write((memory_env_loc + __0xffffffff + fn + "\\code-snippets\\codes.mode"), "r");
		// execute_code("python", _0xffffffff, (fn + "\\code-snippets\\codes.py"));
		system(string("python " + memory_env_loc + __0xffffffff + fn + "\\code-snippets\\codes.py").c_str());

		return 1;
	}

	return 0;
}


void analysis_memory_release_table (string k_data, string v_location) 
{
	string m, __v;
	bool v = true;

	for (auto const &c : k_data) 
	{
		if (c == '[') 
			m.clear();
		else if (c == ']')
		{
			if (_memory_release_table.get_nohint(m) != "") continue;
			
			__v = v_location + m + ".v";
			
			if (_access(__v.c_str(), 0) == 0)
				v = atoi(f_read(__v).c_str()) > 0 ? true : false;

			_memory_release_table.put(m, v ? "true" : "false");
		} else 
			m += c;
	}
	
}


inline void memory_recovery () 
{
	string _t, target, t_k, t_v, memory_release_table_k, table_loc, new_k_data;

	// 0xffffffff .alloc
	string special_alloc = f_read((memory_env_loc + __0xffffffff + fn + "\\code-snippets\\.alloc"));
	string temp_addr = "";

	for (auto const &c : special_alloc) 
	{
		if (c == '-' && temp_addr.size() != 0) 
		{
			__memory_alloc_list.push_back(temp_addr);
			temp_addr.clear();
			continue;
		} else 
		{
			temp_addr += c;
		}
	}

	remove(string(memory_env_loc + __0xffffffff + fn + "\\code-snippets\\.alloc").c_str());

	/* memory recovery */
	for (auto const &address : __memory_alloc_list) 
	{
		_t = memory_env_loc;
		target = _t + __0xffffffff;
		
		if (_access(target.c_str(), 0) == -1) 
			_mkdir(target.c_str());
		
		t_k = cdir(target, "memory-release.table.k", 0);

		t_v = cdir(target, "memory-release.", 0) + address + ".v";
		
		FILE * w;
			w = fopen(t_k.c_str(), "a+");
				fprintf(w, "%s", string("[" + address + "]").c_str());
			fclose(w);
		// f_write(t_k, ("[" + address + "]"));

		f_write(t_v, "0");
	}

	// 计算 level3-memory
	table_loc				= memory_env_loc + __0xffffffff + "memory-release.";
	memory_release_table_k	= f_read(table_loc + "table.k");
	analysis_memory_release_table
		(memory_release_table_k, table_loc)
	;

	for (struct HashTable::keys * k = _memory_release_table.keys_t; k; k = k->next) 
	{
		if (_memory_release_table.get(k->key) == "false") 
		{
			// 可用的三级内存
			new_k_data += ("[" + k->key + "]");
		} else {
			// 已被使用的三级内存，从内存释放表中移除该内存地址，并删除对应的状态文件。
			string tmp = table_loc + k->key + ".v";
			if (_access(tmp.c_str(), 0) == 0) 
				remove(tmp.c_str());
		}
	}
	
	f_write((table_loc + "table.k"), new_k_data);
	/* end of memory recovery */
}

int main(int args, const char * argv[])
{
	if (args > 2) 
	{
		no_args = false;

		string	__program_file_name;
		string	__cpl_param;
		bool	__run = false;

		string	__arg_s;

		Stack cpl_args;

		for (int i = 0; i < args; ++i) 
		{
			__arg_s = (string)argv[i];
			
			if (__arg_s == "--func") 
			{
				if (cpl_args.empty()) 
				{
					__cpl_param = __arg_s;
					cpl_args.push(0);
				} else {
					cout << "Please adjust the compiler parameter order, for example: --key value --key2 value2" << endl;
					return -1;
				}
			} else if (__arg_s == "--memory-binding") 
			{
				if (cpl_args.empty()) 
				{
					__cpl_param = __arg_s;
					cpl_args.push(0);
				} else {
					cout << "Please adjust the compiler parameter order, for example: --key value --key2 value2" << endl;
					return -1;
				}
			} else if (__arg_s == "--reference-codes") 
			{
				if (cpl_args.empty()) 
				{
					__cpl_param = __arg_s;
					cpl_args.push(0);
				}
			} else {
				if (!cpl_args.empty()) 
				{
					cpl_args.pop();

					if (__cpl_param == "--func") 
					{
						if (__arg_s[0] == '0' && __arg_s[1] == 'x') {
							__program_file_name 
										= __memory_address_convert(__arg_s);
							location = __program_file_name;
						} 
						else 
						{
							if (_access(__arg_s.c_str(), 0) == -1) 
							{
								cout << "The compiler tried to find the file, but unfortunately it was not found. Are you sure that the function code file to be run is at this location? (" << __arg_s << ")" << endl;
								return -1;
							}
							fn			=
							__program_file_name 
										= __arg_s;
						}
						__is_func	=
						__run 		= true;
						__func_fn	=
						fn			= __arg_s;
					}
					else
					if (__cpl_param == "--memory-binding") 
					{
						string loc = (memory_env_loc + __0xffffffff + __arg_s);
						if (_access(loc.c_str(), 0) == -1) 
						{
							cout << "The non-existent '" << __arg_s << "'" << endl;
							return -1;
						}
						fn = __arg_s;
					}
					else 
					if (__cpl_param == "--reference-codes") 
					{
						pair<string, string> temp_pair;
						bool who = false;
						string temp_str;
						for (auto const &c : __arg_s) 
						{
							if (c == '[') 
								continue;
							if (c == ']') 
							{
								temp_pair.second = temp_str;
								reference_codes[temp_pair.first] = temp_pair.second;
								temp_str.clear();
								who = false;
							}
							if (c == ',') 
							{
								if (!who) 
								{
									temp_pair.first = temp_str;
									temp_str.clear();
									who = true;
								} else 
								{
									temp_pair.second = temp_str;
									reference_codes[temp_pair.first] = temp_pair.second;
									temp_str.clear();
									who = false;
								}
							} else 
							{
								temp_str += c;
							}
						}
					}
				}
			}
		}

		if (__run) /* 假设针对性支持 `--func` 参数 */
		{
			if (hex_to_dec(__func_fn) > hex_to_dec("0x00000000") && hex_to_dec(__func_fn) <= hex_to_dec("0x0007A120")) 
				cplt_t = Function; 
			else 
			if (hex_to_dec(__func_fn) > hex_to_dec("0x000F4241") && hex_to_dec(__func_fn) <= hex_to_dec("0x0016E360")) 
				cplt_t = ProcessControl;


			no_args = false;

			// cout << "\t\t\t\t\t" << __FILE__ << " at " << __LINE__ << " Access to function" << "\n\t\t\t\t\t__func_fn: " << __func_fn << "\n\t\t\t\t\tfn: " << fn << endl;

			preparing_mission();
// @{ Parse
			yyin = fopen(__program_file_name.c_str(), "r");
				yyparse();
			fclose(yyin);
// @}
			/**
			 * does not apply and therefore causes all @a Symbol-Set
			 and @a Function-Set to be deleted at the end of the function run
			 * 
			*/
			// final_mission();

			for (const auto &trm : temp_uss_tag_list) 
				remove(trm.c_str());

			// Write recovery signal - Process Control
			f_write((memory_env_loc + __0xffffffff + fn + "." + __func_fn + "\\code-snippets\\.mode"), "r");

			// Startup code recovery - Process Control
			system(string("python " + memory_env_loc + __0xffffffff + fn + "." + __func_fn + "\\code-snippets\\pc.py").c_str());

			
		}

		return 0;
	} 
	else 
	if (args == 2) 
	{
		no_args = false;
		
		preparing_mission();

		switch (parameters_exec(argv[1]))
		{
		case 1:
			final_mission();
		case -1:
			return 0;

		default: break;
		}
		
		for (int i = 1; i != args; ++i) 
		{
			if (!(yyin = fopen(argv[1], "r"))) {
				perror(argv[1]);
				return 1;
			}
		}
	}

	// no_args: yes
	no_args = true;

	preparing_mission();

	yyparse();

	final_mission();

	return 0;
}


inline void preparing_mission () 
{
	string __temp_uss_loc = memory_env_loc + __0xffffffff + fn + "\\temp-uss";
	if (_access(__temp_uss_loc.c_str(), 0) == -1) 
		_mkdir(__temp_uss_loc.c_str());
	string __global_set = memory_env_loc + __0xffffffff + fn + "\\global";
	if (_access(__global_set.c_str(), 0) == -1) 
		_mkdir(__global_set.c_str());
	string __symbol_set = memory_env_loc + __0xffffffff + fn + "\\Symbol-Set";
	if (_access(__symbol_set.c_str(), 0) == -1) 
		_mkdir(__symbol_set.c_str());
	string __func_set = memory_env_loc + __0xffffffff + fn + "\\Function-Set";
	if (_access(__func_set.c_str(), 0) == -1) 
		_mkdir(__func_set.c_str());
	

	if (no_args) 
	{
		string loc_pc = memory_env_loc + __0xffffffff + __PC;

		if (_access(loc_pc.c_str(), 0) == -1) 
			f_write(loc_pc, "0");
		
		int pc_n = atoi(f_read(loc_pc).c_str());
		
		f_write(loc_pc, to_string(pc_n + 1));

		pci = pc_n + 1;

		cout << _Const_Apollo_Prompt << "\n\n";
	} 
	else 
	{
		// false
	}
}

inline void final_mission () 
{
	memory_recovery();

	if (no_args) 
	{
		string loc_pc = memory_env_loc + __0xffffffff + __PC;
		
		// TODO Waiting for refactoring code
		if (_access(loc_pc.c_str(), 0) == 0) 
		{
			int n = atoi(f_read(loc_pc).c_str());
			f_write(loc_pc, to_string(n - 1));
		} 
		else /* 在此刻相信函数只会返回 -1 */ 
		{
			f_write(loc_pc, "0");
		}

		for (auto const &f : delete_list) 
			remove(f.c_str());
	} 
	else 
	{
		for (auto const &f : delete_list) 
			remove(f.c_str());
	}
}


/* file */
constexpr int FREAD_BUFFER = 2048;

inline string f_read (const string &__path)
{
    char buffer[FREAD_BUFFER]; memset(buffer, 0, sizeof(buffer));

    if (_access(__path.c_str(), 0) == 0) 
    {
        FILE * fp = fopen(__path.c_str(), "r");
            fread(buffer, sizeof(char), FREAD_BUFFER, fp);
        fclose(fp);
    } else return "non-exist";
    return string((const char *)buffer);
}

inline void f_write (const string &__file, const string &___data)
{
    FILE * fp = fopen(__file.c_str(), "w");
    	fprintf(fp, "%s", ___data.c_str());
    fclose(fp);
}
/* file */

inline string dec_to_hex (int64_t dec) 
{
	string hex = "";

	while (dec != 0) 
	{
		int remainder = dec % 16;
		if (remainder < 10) { 
			hex.insert(hex.begin(), remainder + '0'); 
		} else {
			hex.insert(hex.begin(), remainder - 10 + 'A');
		}
		dec /= 16;
	}

	return hex;
}

inline int64_t hex_to_dec(const string & hexStr) 
{
    int64_t decNum = 0;
    int j = 0;

    for (int i = hexStr.length() - 1; i >= (hexStr[1] == 'x' ? 2 : 0); i--) 
	{
        char c = hexStr[i];
        int n = 0;

        if (c >= '0' && c <= '9') {
            n = c - '0';
        } else if (c >= 'a' && c <= 'f') {  
            n = 10 + c - 'a';
        } else if (c >= 'A' && c <= 'F') {  
            n = 10 + c - 'A';  
        } else{
            return -1;
        }  

       	decNum += n * pow(16, j);

       	j++;  
    }  

    return decNum;
} 

