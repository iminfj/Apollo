/*
 * This file is part of the [Apollo-LS] project.
 * Copyright [2023] [Rui Zhang] and other contributors.
 * See the LICENSE file in the project root directory for the full license information.
 * 
 * The sharing rights for this project belong to all those who have contributed to the project.
 * 
 * Thanks to the following contributors for their dedication and support of this project:
 *   - Rui Zhang 
*/


# pragma once

# define INCLUDE_PATH   (fn + "\\include\\")
# define CXX_I_INCLUDE  (__acm_root + __0xffffffff + fn + "\\include")

# define _ACCESS_ _access

# ifndef CODES_HXX
# ifdef CODES_EXECUTE

# define __0xffffffff   "F\\F\\F\\F\\F\\F\\F\\F\\"

# include <iostream>
using namespace std;
# include <windows.h>
# include <io.h>

enum __language
{
    BAT     = 0,
    C       = 1,    CS = 2,     CXX = 3,    CMD = 4,
    JAVA    = 5,
    PYC     = 6,    PYE = 7,    PWSH = 8,
    VBS     = 9, 
    T       = 10
};
using language = enum __language;

# include <map>
map<string, language> correspondence = {
    { "BAT" , BAT   },
    { "C"   , C     },  { "CS"  , CS    },  { "CPP" , CXX   },  { "CXX" , CXX   },  { "CMD" , CMD   },
    { "JAVA", JAVA  }, 
    { "PYC" , PYC   },  { "PY" , PYE    },  { "PWSH", PWSH  },  { "POWERSHELL", PWSH },
    { "VBS" , VBS   },
    { "HTML", T     },  { "HPP", T      },  { "H",  T       },  { "HH", T   }
};

/* declaration */
    extern string fn;

    string ___acm_root = string((const char *)getenv("APOLLO_MEMORY"));

    inline string convert (const string &, bool);
    inline string _cdir (const string &, const string &, int);
    inline void execute_code (const string &);
    inline void execute_code (const string &, const string &, const string &);
    inline void execute_code_to (const string &, const string &, const string &);
    inline string __to_upper (string &);
// end

/* definition */
    inline void execute_code (const string & memory_address) 
    {
        string loc = ___acm_root + _cdir(convert(memory_address, false), (memory_address + ".exe"), 0);
        system(loc.c_str());
    }
    inline void execute_code (const string & app, const string & memory_address, const string & suffix) 
    {
        string cmd = app + " \"" + ___acm_root + _cdir(convert(memory_address, false), suffix, 0) + "\"";
        system(cmd.c_str());
    }
    inline void execute_code_to (const string & app, const string & memory_address, const string & suffix) 
    {
        string  dir = ___acm_root + _cdir(convert(memory_address, false), "", 0), 
                cmd = app + " " + suffix, 
                s = "cd " + dir + " && " + cmd;
        system(s.c_str());
    }
    inline string _cdir (const string &sa, const string &sb, int w) 
    {
        int n = 0, n1 = 0;
        string r;

        for (auto const &c : sa) 
            if (c == '\\' || c == '/') ++n;

        for (auto const &c : sa) {
            r = r + c;
            if (c == '\\' || c == '/') 
                ++n1;
            if (n1 == (n - w)) 
                break;
        }
        r += sb;
        return r;
    }
    inline string convert (const string &__addr, bool __create) 
    {
        string t, t1 = __addr,  m2;
        int i = 0; for (auto const &c : t1) {
            if (i++ < 2 && t1[1] == 'x') 
                continue;
            m2 += c;
            m2 += '\\';
        }
        t = m2;

        if (__create && _ACCESS_(t.c_str(), 0) == -1) 
            system(string("mkdir " + t).c_str());

        t += ".data";
        return t;
    }
# include <algorithm>
    inline string __to_upper (string & str) 
    {
        transform(str.begin(), str.end(), str.begin(), ::toupper);
        return str;
    }
// end


# else
# define CODES_HXX
# define __0xffffffff   "F\\F\\F\\F\\F\\F\\F\\F\\"

string apollo_inc = string((const char *)getenv("APOLLO_INCLUDE"));


# define APOLLO_INCLUDE apollo_inc

extern string fn;

string _py_before = "\n\
#    Copyright [2023] [Rui Zhang] \n\
# \n\
#   Licensed under the Apache License, Version 2.0 (the \"License\"); \n\
#   you may not use this file except in compliance with the License. \n\
#   You may obtain a copy of the License at \n\
# \n\
#       http://www.apache.org/licenses/LICENSE-2.0 \n\
# \n\
#   Unless required by applicable law or agreed to in writing, software \n\
#   distributed under the License is distributed on an \"AS IS\" BASIS, \n\
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \n\
#   See the License for the specific language governing permissions and \n\
#   limitations under the License. \n\
# \n\
#   Code last change date: 2023-2-14 \n\
# \n\
#   This python code file is automatically generated by Apollo compiler. \n\
#   The purpose of this file is to separate the 'codes' code snippets \n\
# from the `Apollo Code Source File` and to give accurate and valid markings in the source file. \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
def replace (file, old, new): \n\
    code = rfile(file) \n\
    code = code.replace(old, new) \n\
    wfile(file, code) \n\
\n\
def rfile (file): \n\
    with open(file, encoding = 'UTF-8') as f: \n\
        read_all = f.read() \n\
        f.close() \n\
    return read_all \n\
\n\
def wfile (file, data): \n\
    with open(file, 'w', encoding = 'UTF-8') as f: \n\
        f.write(data) \n\
        f.close() \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
import os \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
p_basic = os.path.dirname(__file__) \n\
p_mode  = p_basic + '\\codes.mode' \n\
p_file  = p_basic + '\\codes.file' \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
smode = rfile(p_mode) \n\
sfile = rfile(p_file) \n\
\n\
";

string _py_after = "\n\
for i in range(len(M)): \n\
    old = rfile(M[i]) \n\
    new = ' ' + O[i] + ' ' \n\
\n\
    if smode == 's': \n\
        replace(sfile, old, new) \n\
    elif smode == 'r': \n\
        replace(sfile, new, old) \n\
\n\
# ------------------------------------------------------------------------------------------ \n\
\n\
";


string _py_M_list = "M = [ ";
string _py_O_list = "O = [ ";

string _list_close = "] \n";

# define PUSH(addr)     _py_M_list += ( "'" + convert2(addr) + "', " );    \
                        _py_O_list += ( "'" + addr + "', " )
# define PUSH_OK(addr)  _py_M_list += ( "'" + convert2(addr) + "' " );     \
                        _py_O_list += ( "'" + addr + "' " )

enum __language
{
    BAT     = 0,
    C       = 1,    CS = 2,     CXX = 3,    CMD = 4,
    JAVA    = 5,
    PYC     = 6,    PYE = 7,    PWSH = 8,
    VBS     = 9, 
    T       = 10
};
using language = enum __language;

language crt_language_id;

# include <iostream>
using namespace std;

# include <vector>
# include <map>
map<int, language> lids;

int __codes_index = 0;

map<int, string> idents;
map<int, string> languages;
map<int, string> cplt_args;
map<int, string> snippets;

map<int, string> memory_map;


# define IDENT_PUT(s) ( idents[__codes_index] = ( s ) )
# define LANG_PUT(s) ( languages[__codes_index] = ( s ) )
# define ARGS_PUT(s) ( cplt_args[__codes_index] = ( s ) )
# define SNIPPET_PUT(s) ( snippets[__codes_index] = ( s ) )
# define NEXT ( ++__codes_index )

map<string, language> correspondence = 
{
    { "BAT" , BAT   },
    { "C"   , C     },  { "CS"  , CS    },  { "CPP" , CXX   },  { "CXX" , CXX   },  { "CMD" , CMD   },
    { "JAVA", JAVA  }, 
    { "PYC" , PYC   },  { "PY" , PYE    },  { "PWSH", PWSH  },  { "POWERSHELL", PWSH },
    { "VBS" , VBS   },
    { "HTML", T     },  { "HPP", T      },  { "H",  T       },  { "HH", T   }
};


// Apollo Central Memory && Apollo Memory Model
# include <apollo\Acm\acm.hpp>

/* declaration */
    inline int      __acm_address_assignment    ();
    inline int      co_compilation              ();
    inline language lid_match                   (string);
    inline string   __to_upper                  (string &);
    inline string   convert                     (const string &);
    inline string   convert2                    (const string &);
    inline string   _cdir                       (const string &, const string &, int);
    inline void     execute_code                (const string &);
    inline void     execute_code                (const string &, const string &, const string &);
    inline void     execute_code_to             (const string &, const string &, const string &);
// end

/* defined */
    inline int co_compilation () 
    {
        string code_addr = EMPTY_STR;
        string cmd = EMPTY_STR;
        string tmp = EMPTY_STR;

        __acm_address_assignment();

        for (auto const &v : memory_map) 
        {
            languages[v.first] = __to_upper(languages[v.first]);
            code_addr = __acm_root + ::convert(v.second);
            switch (correspondence[languages[v.first]])
            {
            case language::BAT:
                /* ignore */
                break;

            case language::C:
                execute_code_to(("clang -w -Ofast -o " + v.second + ".exe"), v.second, (v.second + ".c"));
                // cout << "C\t: " << v.second << endl;
                break;
            case language::CXX:
                execute_code_to(("clang++ -w -I " + APOLLO_INCLUDE + " -I " + CXX_I_INCLUDE + " -Ofast -o " + v.second + ".exe"), v.second, (v.second + ".cpp"));
                // cout << "C++\t: " << v.second << endl;
                break;
            case language::CS:
                /* TODO CSC */
                break;
            case language::CMD:
                /* ignore */
                break;

            case language::JAVA:
                execute_code_to("javac", v.second, (v.second + ".java"));
                // cout << "Java\t: " << v.second << endl;
                break;

            case language::PYC:
                execute_code_to("pyinstaller --log-level ERROR -F", v.second, (v.second + ".py"));
                // cout << "Python\t: " << v.second << endl;
                break;
            case language::PYE:
                /* ignore */
                break;
            case language::PWSH:
                /* ignore */
                break;

            case language::VBS:
                /* ignore */
                break;

            case language::T:
                /* ignore */
                break;
            
            default:
                /* ignore */
                break;
            }

FILE_WRITE_SET(_FILE_WRITE_AP);
            if (v.first != (__codes_index - 1)) 
            {
                PUSH(v.second);
                ACMC::__acm_volatile_load_store(_0xffffffff, (v.second + "-"), (fn + "\\code-snippets\\.alloc"));
            } else 
            {
                PUSH_OK(v.second);
                ACMC::__acm_volatile_load_store(_0xffffffff, (v.second + "-"), (fn + "\\code-snippets\\.alloc"));
            }
FILE_WRITE_SET(_FILE_WRITE_DFT);
        }

        _py_M_list += _list_close;
        _py_O_list += _list_close;

        string py = _py_before + _py_M_list + _py_O_list + _py_after;

        ACMC::__acm_volatile_load_store(_0xffffffff, py, (fn + "\\code-snippets\\codes.py"));

        ACMC::__acm_volatile_load_store(_0xffffffff, (fn.size() == 10 && fn[1] == 'x' ? convert(fn) : string(fn)), (fn + "\\code-snippets\\codes.file"));
        ACMC::__acm_volatile_load_store(_0xffffffff, "s", (fn + "\\code-snippets\\codes.mode"));
        execute_code("python", _0xffffffff, (fn + "\\code-snippets\\codes.py"));

        return 0;
    }
    inline language lid_match (string lang) 
    {
        lang = __to_upper(lang);
        if (correspondence.count(lang) > 0) 
            return correspondence[lang];
        return language::T;
    }
# include <algorithm>
    inline string __to_upper (string & str) 
    {
        transform(str.begin(), str.end(), str.begin(), ::toupper);
        return str;
    }
    inline int __acm_address_assignment () 
    {
        for (auto const &v : snippets) 
        {
            memory_map[v.first] = ACMC::__memory_alloc(ACMC::_M__ALLOC_APPOBJ);
            __memory_alloc_list.push_back(memory_map[v.first]);
            auto iswhat = __to_upper(languages[v.first]);
            switch (correspondence[iswhat])
            {
            case language::BAT:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".bat"));
                break;

            case language::C:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".c"));
                break;
            case language::CXX:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".cpp"));
                break;
            case language::CS:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".cs"));
                break;
            case language::CMD:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".cmd"));
                break;

            case language::JAVA:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".java"));
                break;

            case language::PYC:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".py"));
                break;
            case language::PYE:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".py"));
                break;
            case language::PWSH:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".ps1"));
                break;

            case language::VBS:
                ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + ".vbs"));
                break;

            case language::T:
                if (iswhat == "HPP" || iswhat == "H" || iswhat == "HH") 
                {
                    ACMC::__acm_volatile_load_store(_0xffffffff, v.second, (INCLUDE_PATH + idents[v.first] + "." + languages[v.first]));
                } else 
                {
                    ACMC::__acm_volatile_load_store(memory_map[v.first], v.second, (memory_map[v.first] + "." + languages[v.first]));
                }
                break;
            
            default:
                /* ignore */
                break;
            }
            ACMC::__acm_volatile_load_store(memory_map[v.first], v.second);
        }
        return 0;
    }
    inline string convert (const string &__addr) 
    {
        string t, t1 = __addr,  m2;
        int i = 0; for (auto const &c : t1) {
            if (i++ < 2 && t1[1] == 'x') 
                continue;
            m2 += c;
            m2 += '/';
        }
        t = m2;

        t += ".data";

        return t;
    }
    inline string convert2 (const string &__addr) 
    {
        string t, t1 = __addr,  m2;
        int i = 0; for (auto const &c : t1) {
            if (i++ < 2 && t1[1] == 'x') 
                continue;
            m2 += c;
            m2 += '/';
        }

        string t2;

        for (auto const &c : __acm_root) 
        {
            if (c == '\\') 
                t2 += '/';
            else 
                t2 += c;
        }

        t = t2 + m2;

        t += ".data";
        return t;
    }
    inline void execute_code (const string & memory_address) 
    {
        string loc = __acm_root + _cdir(convert(memory_address), (memory_address + ".exe"), 0);
        system(loc.c_str());
    }
    inline void execute_code (const string & app, const string & memory_address, const string & suffix) 
    {
        string cmd = app + " \"" + __acm_root + _cdir(convert(memory_address), suffix, 0) + "\"";
        system(cmd.c_str());
    }
    inline void execute_code_to (const string & app, const string & memory_address, const string & suffix) 
    {
        string  dir = __acm_root + _cdir(convert(memory_address), "", 0), 
                cmd = app + " " + suffix, 
                s = "cd " + dir + " && " + cmd;
        system(s.c_str());
    }
    inline string _cdir (const string &sa, const string &sb, int w) 
    {
        int n = 0, n1 = 0;
        string r;

        for (auto const &c : sa) 
            if (c == '\\' || c == '/') ++n;

        for (auto const &c : sa) {
            r = r + c;
            if (c == '\\' || c == '/') 
                ++n1;
            if (n1 == (n - w)) 
                break;
        }
        r += sb;
        return r;
    }
// end

# endif // CODES_EXECUTE
# else
    extern map<int, string> idents;
    extern map<int, string> languages;
    extern map<int, string> cplt_args;
    extern map<int, string> snippets;

    extern inline int co_compilation ();
    extern inline language lid_match (const string &);
    extern inline int __acm_address_assignment ();

    extern int __codes_index;

    # define IDENT_PUT(s) ( idents[__codes_index] = ( s ) )
    # define LANG_PUT(s) ( languages[__codes_index] = ( s ) )
    # define ARGS_PUT(s) ( cplt_args[__codes_index] = ( s ) )
    # define SNIPPET_PUT(s) ( snippets[__codes_index] = ( s ) )
    # define NEXT ( ++__codes_index )
# endif // CODES_HXX


